<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="Emailto chunk.cn at gmail.com"/><title>numpy中broadcast机制应用 | Chunk</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/font.css"/><link rel="stylesheet" type="text/css" href="/css/noise.css"/><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about.html">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/python/">python</a></div><div class="post-time">2018-02-11</div></div></div><div class="container post-header"><h1>numpy中broadcast机制应用</h1></div><div class="container post-content"><p><strong><em>摘要</em></strong> 这篇文章主要介绍numpy库中对矩阵实现的Broadcasting机制的使用方法。broadcasting机制的使用往往代表着数据结构中以空间换时间思想的实现，使用这种方法，往往可以将循环替换为一次全并行的计算，或者说将一维数组的运算改为矩阵的运算。</p>
<h2 id="1-简单-broadcasting-引入"><a href="#1-简单-broadcasting-引入" class="headerlink" title="1. 简单 broadcasting 引入"></a>1. 简单 <strong><em>broadcasting</em></strong> 引入</h2><p>首先考虑这样一个简单的循环求和运算<br>$$\sum_{i=1}^{N}(x_i - 5)$$<br>容易地，可以使用下面的程序完成计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_x</span><span class="params">(x)</span>:</span></span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        sum_1 += x[i] - <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> sum_1</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这时候的计算复杂度是$O(N)$，使用broadcast机制，可以使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_new</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x - <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p>两种方法的结果效果一致。这里考虑到numpy中sum函数的使用，计算复杂度没有降低。但是，此处值得借鉴的是，numpy没有拘泥于两个相减变量必须相同维度，方便的实现了上面的求和式，并且提高了代码的可读性。</p>
<h2 id="2-broadcasting-进阶一"><a href="#2-broadcasting-进阶一" class="headerlink" title="2. broadcasting 进阶一"></a>2. <strong><em>broadcasting</em></strong> 进阶一</h2><p>然而，实际中可能会出现下面这种公式：<br>$$\sum<em>{i=1}^{N}\sum</em>{j=1}^{M}(x_i-y_j)$$<br>一般的实现方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y)):</span><br><span class="line">            sum_2 += x[i] - y[j]</span><br><span class="line">    <span class="keyword">return</span> sum_2</span><br></pre></td></tr></table></figure></p>
<p>假设x,y都是用array生成的一维行向量。这个时候，计算复杂度是$O(NM)$，可以视为$O(N^2)$，这段代码在稍长一点的数组间进行计算时，会明显的降低程序的执行速度。</p>
<p>使用broadcasting时，可以将计算复杂度大大降低。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2_new</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(x.reshape(len(x), <span class="number">1</span>) - y)</span><br></pre></td></tr></table></figure></p>
<p>简单一行代码就完成了一次嵌套for循环。这里reshape函数，将一维行向量变x为一维列向量, 当列向量减行向量的时候，numpy会调动<strong><em>broadcasting</em></strong> 机制，自动将前者填充一个N行M列的矩阵，每一行都和y同长度，分别减去y。这样就实现了x中每一个元素和y中的每一个元素相减，并求和。</p>
<h2 id="3-再进阶"><a href="#3-再进阶" class="headerlink" title="3. 再进阶"></a>3. 再进阶</h2><p>前面两种方法，如果使用得当，已经可以很快捷的编写出方便阅读和使用的python代码。但是有时候，可能会出现比较偏执的三个求和号：<br>$$\sum<em>{k=1}^{N}\sum</em>{j=1}^{N}\sum_{i=1}^{N}(x_k - x_i)(y_k - y_j)$$<br>容易地，这里当然可以使用三个嵌套的for循环完成计算，但是计算耗时之大，显而易见！<br>这里x,y是相同长度的一位行向量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x.reshape(len(x), <span class="number">1</span>, <span class="number">1</span>).repeat(len(x), axis=<span class="number">1</span>) - x) * (y.reshape(len(y), <span class="number">1</span>, <span class="number">1</span>).repeat(len(y), axis=<span class="number">2</span>) - y.reshape(len(y), <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>这种方法的受众比较少，使用时需要将x，y都投射到三维矩阵中进行考虑，略有复杂，为了追求程序的简洁性，可以尝试，相同的，此时程序的可读性比较差。</p>
<blockquote>
<p>三维下使用broadcasting的确可以大大提升运算速度，但是同样的代价是立方级别的内存空间，对过长的行向量使用时，务必要注意，内存很容易出现爆炸，导致电脑卡住！！！</p>
</blockquote>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'chunkcn';
var disqus_identifier = 'numpy中broadcast机制应用/';
var disqus_title = 'numpy中broadcast机制应用';
var disqus_url = 'https://wangxuchuang.com/numpy中broadcast机制应用/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"/><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-116724859-1');ga('send','pageview');</script></body></html>